'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var h = require('virtual-dom/h');

// helpers

// todo: not being used
var round = function round(v) {
	return Math.round(v * 10000) / 10000;
};

var polarToX = function polarToX(angle, distance) {
	return Math.cos(angle - Math.PI / 2) * distance;
};

var polarToY = function polarToY(angle, distance) {
	return Math.sin(angle - Math.PI / 2) * distance;
};

var points = function points(_points) {
	return _points.map(function (point) {
		return point[0].toFixed(4) + ',' + point[1].toFixed(4);
	}).join(' ');
};

var noSmoothing = function noSmoothing(points) {
	var d = 'M' + points[0][0].toFixed(4) + ',' + points[0][1].toFixed(4);
	for (var i = 1; i < points.length; i++) {
		d += 'L' + points[i][0].toFixed(4) + ',' + points[i][1].toFixed(4);
	}
	return d + 'z';
};

var axis = function axis(opt) {
	return function (col) {
		return h('polyline', Object.assign(opt.axisProps(col), {
			points: points([[0, 0], [polarToX(col.angle, opt.chartSize / 2), polarToY(col.angle, opt.chartSize / 2)]])
		}));
	};
};

var shape = function shape(columns, opt) {
	return function (data, i) {
		return h('path', Object.assign(opt.shapeProps(data), {
			d: opt.smoothing(columns.map(function (col) {
				var val = data[col.key];
				if ('number' !== typeof val) {
					throw new Error('Data set ' + i + ' is invalid.');
				}

				return [polarToX(col.angle, val * opt.chartSize / 2), polarToY(col.angle, val * opt.chartSize / 2)];
			}))
		}));
	};
};

var scale = function scale(opt, value) {
	return h('circle', Object.assign(opt.scaleProps(value), {
		cx: 0, cy: 0, r: value * opt.chartSize / 2
	}));
};

var caption = function caption(opt) {
	return function (col) {
		return h('text', Object.assign(opt.captionProps(col), {
			x: polarToX(col.angle, opt.size / 2 * .95).toFixed(4),
			y: polarToY(col.angle, opt.size / 2 * .95).toFixed(4),
			dy: (opt.captionProps(col).fontSize || 2) / 2
		}), col.caption);
	};
};

var defaults = {
	size: 100, // size of the chart (including captions)
	axes: true, // show axes?
	scales: 3, // show scale circles?
	captions: true, // show captions?
	captionsPosition: 1.2, // where on the axes are the captions?
	smoothing: noSmoothing, // shape smoothing function
	axisProps: function axisProps() {
		return { className: 'axis' };
	},
	scaleProps: function scaleProps() {
		return { className: 'scale', fill: 'none' };
	},
	shapeProps: function shapeProps() {
		return { className: 'shape' };
	},
	captionProps: function captionProps() {
		return {
			className: 'caption',
			textAnchor: 'middle', fontSize: 3,
			fontFamily: 'sans-serif'
		};
	}
};

var render = function render(columns, data) {
	var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	if ('object' !== (typeof columns === 'undefined' ? 'undefined' : _typeof(columns)) || Array.isArray(columns)) {
		throw new Error('columns must be an object');
	}
	if (!Array.isArray(data)) {
		throw new Error('data must be an array');
	}
	opt = Object.assign({}, defaults, opt);
	opt.chartSize = opt.size / opt.captionsPosition;

	columns = Object.keys(columns).map(function (key, i, all) {
		return {
			key: key, caption: columns[key],
			angle: Math.PI * 2 * i / all.length
		};
	});

	var groups = [h('g', data.map(shape(columns, opt)))];
	if (opt.captions) groups.push(h('g', columns.map(caption(opt))));
	if (opt.axes) groups.unshift(h('g', columns.map(axis(opt))));
	if (opt.scales > 0) {
		var scales = [];
		for (var i = opt.scales; i > 0; i--) {
			scales.push(scale(opt, i / opt.scales));
		}
		groups.unshift(h('g', scales));
	}

	var delta = (opt.size / 2).toFixed(4);
	return h('g', {
		transform: 'translate(' + delta + ',' + delta + ')'
	}, groups);
};

module.exports = render;